---
layout: post
title: digital opetation 
tags: java digital 
category: java
---

# 数字运算

* java 中的数值存储有两种格式，整数和小数，代表分别是int，double，两种格式代表了不同的存储结构，也对应不同的运算规则。
* 计算机的整数分为sign和unsign类型，java中强制使用sign类型的，所以这里只介绍sign类型的。
* 这里主要介绍正数的运算

## 整数的表示和运算

### 整数的存储

java中的整数是采用补码的格式存储的，大于一个byte的整数采用big-endian的方式。

#### 补码

计算机中表示sign数大致有三种形式，补码（two's-complement），原码（sign-magnitude），反码（ones' complement）

先看unsign的二进制存储，

如二进制**1100**，转换为10进制是(1x2x2x2+1x2x2+0x2+0x1)

在 sign中，二进制的首位会用来区分正负数，根据区分的原则，分为补码，原码，反码。

* 补码，会把首位的数值变为负数，**1100**表示就是(-1x2x2x2+1x2x2+0x2+0x1)

* 反码，跟补码类似，首位是-1，不过首位的结果要减1，**1100**表示就是(-1x(2x2x2-1)+1x2x2+0x2+0x1)

* 原码，会把首位单独表示正负数，1代表负数，0代表正数，**1100**就是(1x2x2+0x2+0x1)

原码和反码都会存在正负0的问题，补码解决了这个问题，同时也简化加减运算。

#### big-endian

当数值大小多于一个byte的时候，就会大小端的问题，java是采用的big-endian。

big-endian,存储是高位在前面，little-endian是低位在前面

比如short，0x00ff，

* big-endian的存储第一个byte是00，第二个byte是ff
* little-endian的存储第一个byte是ff，第二个是00

#### 类型转化

不同长度数据的转换会有一定的规则。以int和short为例

* int转short，长度变小，是直接截断，如int 0x00ff，转为short为0xff，因为是截断所以数值的正负和大小都变化了，int是是正数，转成short就变为了负数
* short转int，数字扩展分为0扩展，和符号扩展。
  -  0扩展是扩充的位置都补0，适用于unsign数值，如short 0xff，转为int是0x00ff
  -  符号扩展是java采用的，扩充的数字是首位的数，如short 0xff，转为int是 0xffff

### 运算

### 位运算

有四种位运算，&,|,~,^，都是纯粹的位操作，不涉及符号位的特殊处理，其中^，代表异或，相同为0不同为1

* 只能用于整形数据，小数是没法用的
* 不同长度的数，会统一转为最长数据

#### 移位运算

* 左移(<<)很简单，丢弃最高k位，右边补0
* 右移分为，逻辑右移(>>>)和算术右移(>>)
 - 逻辑右移是丢弃最低k位，右边补0
 - 算术右移是丢弃最低k位，根据原最高位0或1，右边补全0或1 

#### 加减

unsign的加减是很简答直接的，sign的加减用不同的编码规则，有不同的计算规则

所以说，补码的规则可以说是sign编码的最优解了，加法只需要普通的二进制加法就可以了。

原码，和反码的加法需要特殊的处理，因为java强制采用补码，这里就不解释了

同理减法在是被减数取反在进行加法

#### 乘法

乘法可以转化为位移和加法运算，如a*3可以转换为(a<<1)+a，因为补码的编码规则，**不需要考虑符号位**

#### 除法

除法分为两种情况

* 如果除数是2的倍数，可以转化为逻辑右移。
* 非2的倍数，只能是转化为减法了。
